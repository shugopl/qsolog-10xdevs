You are Claude Code working in an empty mono-repo (or partially created). Goal: build a production-quality app:
Angular 21 SPA + Java 25 Spring Boot 4 WebFlux + PostgreSQL R2DBC + JWT.

HARD RULES (anti-hallucination):
1) Never assume files exist — always inspect repo tree first.
2) Make only the changes needed for the current step.
3) After implementing, run build/tests and fix failures.
4) If you need TODOs, mark them clearly with "TODO(step-X)" and keep app runnable.
5) After finishing, print the updated file tree and short run instructions.

Repo structure required:
/
  backend/
  frontend/
  docker/
  .github/workflows/
  README.md

Business decisions to follow:
- Roles: ADMIN and OPERATOR exist from day 1. Design should allow easy extension to “club log” (multi-operator/shared log) later.
- QSO minimal ADIF/LoTW fields required: CALL(theirCallsign), QSO_DATE(UTC), TIME_ON(UTC), MODE, plus BAND or FREQ(required at least one). For MVP: require BAND, FREQ optional.
- UTC everywhere.
- Do not hard-block duplicates: detect potential duplicates (same theirCallsign + qsoDate + band + mode, optionally TIME_ON rounded) and return a warning/flag in API response so UI can confirm save.
- QSL model MVP:
  qslStatus: {NONE, SENT, CONFIRMED}
  lotwStatus: {UNKNOWN, SENT, CONFIRMED}
  eqslStatus: {UNKNOWN, SENT, CONFIRMED}
  Stats should include “all” and “confirmed”.
- Export priority: ADIF first; CSV secondary.
- Callsign lookup: HamQTH API with simple cache, used as suggestions only (never overwrite user data automatically).
- AI helper: suggestion-only, PL/EN, neutral/loose tone; keep simple history of generated reports.

Now: start by showing the current file tree. If repo is empty, create skeleton folders and baseline README placeholder only. STOP after that.
