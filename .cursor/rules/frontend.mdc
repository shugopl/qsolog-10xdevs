# frontend.mdc — Frontend rules (Angular)

## Stack expectations
- Angular (current), Angular Material UI
- Reactive forms, RxJS
- Routing + guards
- Strict TypeScript

If you use SSR or other UI libs, keep the same quality/structure rules.

---

## UI/UX principles
- Keep UI consistent with existing Material layout.
- Prefer **browse + filter + details** patterns.
- Loading/error/empty states are mandatory in any data screen.
- Avoid showing raw IDs; show callsigns/emails/usernames; ID only where needed for debugging (admin only).

---

## State and data flow
- API calls via a dedicated `ApiClient`/service layer.
- Never call `fetch` directly inside components.
- Components should be mostly “dumb”; business logic lives in services/facades.
- Prefer typed DTOs aligned with backend.

---

## Date/time rules (critical)
- Always handle QSO date/time as UTC in transport.
- UI may display local time but must not change stored value unless user edits.
- Always show timezone or clarify “UTC” in forms and exports.

---

## Security in UI
- Role-based UI: Admin screens hidden unless user has role ADMIN.
- Do not store tokens in unsafe places; prefer secure storage patterns used in the repo.
- Any admin-only route must have a guard.

---

## Naming and structure (recommended)
- `features/qso/` — QSO list, details, create form, import/export
- `features/admin/` — admin users browse (read-only)
- `shared/` — components/pipes/utils, no business logic
- `core/` — auth, interceptors, guards, configuration

---

## QSO screens (MVP expectations)
1. **QSO List**: table + filters (band, mode, date range, callsign).
2. **QSO Create**: validated form with sensible defaults (UTC now, last used station callsign).
3. **QSO Details**: readonly summary, export preview.
4. **ADIF Export**: user can export filtered set.
5. **ADIF Import**: show preview + import summary + error rows (do not silently drop).

Validation hints:
- callsign: trimmed, uppercase normalization for display (store canonical + raw if needed)
- band/mode: dropdown from enums (ADIF core lists)
- time: ensure proper parsing and UTC conversion

---

## Testing rules (frontend)
- At least:
  - one component test for list/filter logic or service mapping
  - one guard/auth test (ADMIN route protection)
- When changing DTO mapping, update tests.

---

## AI-specific “do / don’t”
DO:
- reuse existing Material components/patterns
- ensure strong typing end-to-end
- add error handling and toasts/snackbars
DON’T:
- introduce new state library unless required
- bypass guards for admin routes
- add heavy UI dependencies without justification

---

## Angular 20+ standards checklist (must follow)
This section defines “modern Angular” expectations for this repo.

### 1) Standalone by default
- All components, directives, pipes are **standalone** unless integrating legacy code.
- Routing uses standalone `Routes` + lazy loading per feature.
- Avoid creating new NgModules.

### 2) Modern template syntax
- Prefer new control flow:
  - `@if / @else`
  - `@for (...; track ...)`
  - `@switch`
- Use `@defer` for heavy/optional UI (e.g., import preview, large tables).
- Always provide stable tracking keys in `@for`.

### 3) Signals-first UI state
- Keep view state in signals:
  - `filters`, `sort`, `pagination`, `selectedRow`, `viewModel`
- Use:
  - `computed(...)` for derived view state
  - `effect(...)` only for controlled side effects (logging, auto-load on filter changes)
- Avoid mixing too many sources of truth (signals + mutable fields).

### 4) RxJS where it belongs (async + streams)
- Use `Observable` for:
  - HTTP calls (HttpClient)
  - WebSocket/SSE streams (if used)
  - combining async sources
- Convert to signals for templates via `toSignal(...)` when needed.
- Never leave unmanaged subscriptions in components. Prefer:
  - `async` pipe in templates
  - `takeUntilDestroyed()` in services/components when subscribing manually

### 5) Functional DI & providers (preferred)
- Prefer functional providers and interceptor registration (Angular modern style).
- Avoid deprecated patterns and legacy DI workarounds.

### 6) Change detection / performance rules
- Prefer `ChangeDetectionStrategy.OnPush` for all new components.
- Avoid expensive work in templates; compute in facade/service or `computed(...)`.
- Use `@defer` + placeholder for heavy sections.
- Use virtual scroll for large lists (if the dataset can be big).

### 7) Zoneless (optional, only if repo supports it)
If the repo is configured for zoneless:
- Avoid relying on Zone.js side-effects.
- Trigger UI updates via signals/observables.
If not configured, do not attempt migration without explicit task.

### 8) SSR/Hydration (optional)
If SSR/hydration is enabled in the repo:
- Ensure guards/resolvers and API calls are SSR-safe.
- Avoid direct access to `window/document` without platform checks.

### 9) Strict typing & linting
- `strict` and `strictTemplates` must remain enabled.
- No `any` unless extremely justified and localized.
- DTOs must be typed and aligned with backend contracts.

### 10) “Modern Angular” acceptance criteria for new features
A feature is considered Angular 20+ compliant if:
- standalone routes + lazy-loaded feature
- control flow uses `@if/@for` (not `*ngIf/*ngFor`)
- state managed via signals (facade/service), not component fields
- no unmanaged subscriptions
- OnPush enabled
- loading/error/empty states present